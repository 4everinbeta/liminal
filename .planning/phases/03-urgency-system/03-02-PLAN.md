---
phase: 03-urgency-system
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/components/CapacitySummary.tsx
  - frontend/lib/notifications.ts
  - frontend/lib/hooks/useNotifications.ts
autonomous: true

must_haves:
  truths:
    - "Due today section displays hours remaining in workday and task count"
    - "Capacity summary shows how many tasks fit in remaining time"
    - "Over-capacity state shown with warm warning, not anxiety-inducing alarm"
    - "Notification permission requested only on explicit user gesture, never auto-prompted"
    - "Notification scheduled 1 hour before deadline for opted-in users"
  artifacts:
    - path: "frontend/components/CapacitySummary.tsx"
      provides: "Due today capacity display component"
      exports: ["CapacitySummary"]
    - path: "frontend/lib/notifications.ts"
      provides: "Notification scheduling and permission utilities"
      exports: ["requestNotificationPermission", "scheduleTaskNotification", "cancelTaskNotification"]
    - path: "frontend/lib/hooks/useNotifications.ts"
      provides: "React hook for notification permission state and scheduling"
      exports: ["useNotifications"]
  key_links:
    - from: "frontend/lib/hooks/useNotifications.ts"
      to: "frontend/lib/notifications.ts"
      via: "import scheduling and permission functions"
      pattern: "import.*from.*notifications"
    - from: "frontend/components/CapacitySummary.tsx"
      to: "frontend/lib/api.ts"
      via: "Task type import for type safety"
      pattern: "import.*Task.*from.*api"
---

<objective>
Create the capacity summary component and browser notification system.

Purpose: CapacitySummary creates ADHD-activating scarcity framing ("2 hours left, 3 tasks remaining") that makes time tangible. Notifications provide the 1-hour-before nudge that catches ADHD brains before they forget. These are independent features that don't depend on urgency color hooks.

Output: CapacitySummary.tsx component, notifications.ts utility library, useNotifications.ts hook.
</objective>

<execution_context>
@/home/rbrown/.claude/get-shit-done/workflows/execute-plan.md
@/home/rbrown/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-urgency-system/03-RESEARCH.md

@frontend/lib/api.ts (Task interface: due_date, effort_score, estimated_duration, status)
@frontend/components/TaskCard.tsx (existing component pattern reference)
@frontend/lib/confetti.ts (existing lib pattern reference)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CapacitySummary component</name>
  <files>frontend/components/CapacitySummary.tsx</files>
  <action>
    Create `frontend/components/CapacitySummary.tsx` as a 'use client' component.

    **Props:** `{ tasks: Task[] }` where Task is imported from `@/lib/api`.

    **Logic:**
    1. Calculate remaining work hours today: `Math.max(0, 17 - currentHour)` where currentHour = `now.getHours() + now.getMinutes() / 60`. Hardcode 9-5 workday for MVP (per RESEARCH.md open question 1).
    2. Filter tasks due today: tasks where `new Date(t.due_date).toDateString() === now.toDateString()` and status !== 'done'.
    3. For each task, estimate hours: `(t.estimated_duration || t.effort_score || 30) / 60` (fallback 30 min per RESEARCH.md).
    4. Sort tasks by estimated hours ascending (shortest first for greedy fit).
    5. Count how many fit: iterate sorted tasks, accumulate hours, count while accumulated <= hoursRemaining.
    6. Calculate total task hours for the day.

    **Render:**
    - Container: `bg-blue-50 p-4 rounded-lg border border-blue-200` (calming blue, not alarming)
    - Header: "Due Today" in `text-sm font-medium text-blue-900`
    - Main number: hours remaining in `text-2xl font-bold text-blue-700` with format `{hoursRemaining.toFixed(1)}h left`
    - Task fit count: `{tasksFit} of {todayTasks.length} tasks fit` in `text-xs mt-2`
    - Over capacity: if totalTaskHours > hoursRemaining, text color changes to `text-orange-600` and appends "(over capacity)" -- use warm orange not red, per ADHD-safe design
    - If after work hours (hoursRemaining === 0): show "Workday ended" with gentler styling
    - If no tasks due today: show "No tasks due today" in neutral tone

    Use `useMemo` for the capacity calculation to avoid recalculating on every render.

    Export as default: `export default CapacitySummary`
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - Component exports CapacitySummary (grep for "export default CapacitySummary")
    - No shame language in component (grep for "late\|fail\|overdue\|behind" should find zero matches)
    - Uses Task type from @/lib/api (grep for "import.*Task.*from")
  </verify>
  <done>
    - CapacitySummary renders remaining work hours and task count for today
    - Over-capacity shown with warm orange text, not alarming red
    - Edge cases handled: no tasks, after work hours, tasks without duration estimates
    - Component follows existing patterns (PascalCase, 'use client', Tailwind styling)
  </done>
</task>

<task type="auto">
  <name>Task 2: Create notification utility library and hook</name>
  <files>
    frontend/lib/notifications.ts
    frontend/lib/hooks/useNotifications.ts
  </files>
  <action>
    1. Create `frontend/lib/notifications.ts` with these exports:

    **requestNotificationPermission(): Promise&lt;boolean&gt;**
    - Check `'Notification' in window` -- return false if not supported
    - If already 'granted': return true
    - If already 'denied': return false (don't bother user again)
    - Otherwise: await Notification.requestPermission(), return result === 'granted'

    **scheduleTaskNotification(taskId: string, taskTitle: string, dueDate: string): number | null**
    - Calculate msUntilNotification = (due - 1 hour) - now
    - If msUntilNotification <= 0 or > 25 * 24 * 60 * 60 * 1000 (25 days, browser setTimeout limit): return null
    - Use setTimeout to create notification at the right time
    - Notification: title "Liminal: Task due soon", body `"${taskTitle}" is due in 1 hour`, tag `task-${taskId}` (tag deduplicates)
    - Return the timeout ID (as number) so it can be cancelled

    **cancelTaskNotification(timeoutId: number): void**
    - clearTimeout(timeoutId)

    Store active notification timeout IDs in a module-level Map<string, number> keyed by taskId. When scheduling, cancel any existing notification for that task first (prevents duplicates on re-render).

    2. Create `frontend/lib/hooks/useNotifications.ts`:

    **useNotifications() hook** returns:
    - `permission: NotificationPermission` ('default' | 'granted' | 'denied')
    - `isSupported: boolean` (whether browser supports Notification API)
    - `showSoftAsk: boolean` (whether to show the soft-ask prompt)
    - `requestPermission: () => Promise<boolean>` (triggers actual browser permission dialog)
    - `dismissSoftAsk: () => void` (user said "not now" to soft ask)
    - `scheduleNotification: (taskId, title, dueDate) => void` (schedules if permission granted)

    Use useState for permission state. Initialize from `Notification.permission` with SSR safety check (`typeof window !== 'undefined' && 'Notification' in window`).

    The soft-ask pattern: When a task with a due_date is first encountered, show a friendly prompt ("Get reminded 1 hour before deadlines?") BEFORE triggering the browser permission dialog. This avoids Chrome/Firefox penalties for aggressive permission requests (RESEARCH.md pitfall 3). The showSoftAsk state defaults to false and gets set to true via a `triggerSoftAsk()` function.
  </action>
  <verify>
    - `cd frontend && npx tsc --noEmit` compiles without errors
    - notifications.ts exports requestNotificationPermission, scheduleTaskNotification, cancelTaskNotification
    - useNotifications.ts exports useNotifications hook
    - No auto-request of notification permission (grep for "requestPermission" should only appear inside functions, never at module level or in useEffect without user gesture guard)
    - SSR safety: check for `typeof window` guard (grep confirms)
  </verify>
  <done>
    - Notification permission flow follows soft-ask pattern (never auto-prompts browser dialog)
    - Notifications scheduled 1 hour before deadline via setTimeout
    - Active notifications tracked by taskId and deduplicatable
    - Hook provides clean API for components to request permission and schedule notifications
    - SSR-safe: no window access during server rendering
    - Handles edge cases: browser doesn't support Notification API, permission already denied, due date too far in future
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd frontend && npx tsc --noEmit` passes
2. CapacitySummary renders capacity info with calming blue styling and warm orange for over-capacity
3. Notification permission never auto-requested (grep confirms no bare Notification.requestPermission() calls)
4. All three new files export their functions/components
5. No shame language anywhere in new code
</verification>

<success_criteria>
- CapacitySummary component shows "X.Xh left" and "N of M tasks fit" for today
- Over-capacity uses orange, not red (ADHD-safe)
- Notification system follows soft-ask -> browser permission -> schedule pattern
- Notifications scheduled 1 hour before deadline with setTimeout
- All code handles SSR, missing data, and browser compatibility gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/03-urgency-system/03-02-SUMMARY.md`
</output>
