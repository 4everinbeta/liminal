---
phase: 02-capture-feedback
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/hooks/useDraftPreservation.ts
  - frontend/lib/hooks/useVoiceInput.ts
  - frontend/lib/hooks/useAutoSave.ts
autonomous: true

must_haves:
  truths:
    - "Form drafts persist in sessionStorage across page navigation"
    - "Voice input transcribes speech to text in real-time (Chrome/Edge)"
    - "Auto-save debounces to prevent server overload"
  artifacts:
    - path: "frontend/lib/hooks/useDraftPreservation.ts"
      provides: "Session-based draft storage hook"
      exports: ["useDraftPreservation"]
    - path: "frontend/lib/hooks/useVoiceInput.ts"
      provides: "Web Speech API wrapper with graceful degradation"
      exports: ["useVoiceInput"]
    - path: "frontend/lib/hooks/useAutoSave.ts"
      provides: "Debounced auto-save with race condition prevention"
      exports: ["useAutoSave"]
  key_links:
    - from: "useDraftPreservation"
      to: "sessionStorage"
      via: "JSON serialization"
      pattern: "sessionStorage\\.(get|set)Item"
    - from: "useVoiceInput"
      to: "SpeechRecognition"
      via: "Web Speech API"
      pattern: "SpeechRecognition|webkitSpeechRecognition"
---

<objective>
Create reusable hooks for draft preservation, voice input, and auto-save that form the foundation for Phase 2's frictionless capture features.

Purpose: These hooks encapsulate complex browser APIs and patterns (sessionStorage, Web Speech API, debouncing with race condition prevention) so the quick capture UI can focus on UX without reimplementing low-level concerns.

Output: Three hooks in `frontend/lib/hooks/` ready for integration into quick capture components.
</objective>

<execution_context>
@/home/rbrown/.claude/get-shit-done/workflows/execute-plan.md
@/home/rbrown/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-capture--and--feedback/02-RESEARCH.md

# Phase 1 established patterns
@.planning/phases/01-foundation/01-01-SUMMARY.md
@frontend/lib/store.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useDraftPreservation hook</name>
  <files>frontend/lib/hooks/useDraftPreservation.ts</files>
  <action>
Create a custom hook that syncs form state to sessionStorage with these features:

1. Initialize state from sessionStorage if available (SSR-safe with typeof window check)
2. Sync to sessionStorage on every state change via useEffect
3. Provide clearDraft function that removes from sessionStorage and resets to initial value
4. Return tuple: [value, setValue, clearDraft]

Key implementation details:
- Use JSON.stringify/parse for serialization
- Wrap sessionStorage access in try/catch (quota exceeded handling)
- SSR-safe: Check typeof window !== 'undefined' before accessing sessionStorage
- Generic type parameter for type safety: useDraftPreservation<T>(key: string, initialValue: T)

Pattern from research:
```typescript
function useDraftPreservation<T>(key: string, initialValue: T) {
  const [value, setValue] = useState<T>(() => {
    if (typeof window === 'undefined') return initialValue
    try {
      const stored = sessionStorage.getItem(key)
      return stored ? JSON.parse(stored) : initialValue
    } catch {
      return initialValue
    }
  })

  useEffect(() => {
    try {
      sessionStorage.setItem(key, JSON.stringify(value))
    } catch (e) {
      console.warn('sessionStorage quota exceeded')
    }
  }, [key, value])

  const clearDraft = useCallback(() => {
    sessionStorage.removeItem(key)
    setValue(initialValue)
  }, [key, initialValue])

  return [value, setValue, clearDraft] as const
}
```

Create the hooks directory if it doesn't exist.
  </action>
  <verify>
1. `npm run build` passes (no TypeScript errors)
2. Hook exports correctly: `grep -r "useDraftPreservation" frontend/lib/hooks/`
  </verify>
  <done>
useDraftPreservation hook exists, is type-safe, handles SSR, and provides clearDraft function.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useVoiceInput hook</name>
  <files>frontend/lib/hooks/useVoiceInput.ts</files>
  <action>
Create a custom hook that wraps Web Speech API with graceful degradation:

1. Check for SpeechRecognition support (handle webkit prefix)
2. Return isSupported: false if browser doesn't support it
3. Provide start/stop functions for recording control
4. Call onResult callback with transcript (interim results for real-time feedback)
5. Handle errors gracefully (not-allowed, no-speech, etc.)
6. Clean up recognition instance on unmount

Key implementation details:
- Browser prefix handling: window.SpeechRecognition || window.webkitSpeechRecognition
- Configure: continuous = false, interimResults = true, lang = 'en-US'
- Handle onerror with specific messages for 'not-allowed' (microphone permission)
- Store recognition instance in useRef to persist across renders
- Return cleanup function from useEffect

Interface:
```typescript
interface UseVoiceInputReturn {
  start: () => void
  stop: () => void
  isListening: boolean
  isSupported: boolean
}

function useVoiceInput(onResult: (transcript: string) => void): UseVoiceInputReturn
```

Add TypeScript declarations for SpeechRecognition (browser API not in default types):
```typescript
// At top of file
declare global {
  interface Window {
    SpeechRecognition: typeof SpeechRecognition
    webkitSpeechRecognition: typeof SpeechRecognition
  }
}
```
  </action>
  <verify>
1. `npm run build` passes
2. Hook exports correctly: `grep -r "useVoiceInput" frontend/lib/hooks/`
3. Has browser prefix handling: `grep -r "webkitSpeechRecognition" frontend/lib/hooks/`
  </verify>
  <done>
useVoiceInput hook exists, handles browser compatibility, provides start/stop/isListening/isSupported, and cleans up on unmount.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useAutoSave hook</name>
  <files>frontend/lib/hooks/useAutoSave.ts</files>
  <action>
Create a custom hook for debounced auto-save with race condition prevention:

1. Debounce save calls (default 2000ms as per requirements)
2. Track request IDs to ignore out-of-order responses
3. Return status: 'idle' | 'saving' | 'saved' | 'error'
4. Clean up timeout on unmount (prevent memory leaks)
5. Reset status to 'idle' after showing 'saved' (2 second display)

Key implementation details:
- Use useRef for timeout and requestId (persist across renders)
- Increment requestId before each save, check it matches after await
- Clear timeout in cleanup function
- Status transitions: idle -> saving -> saved -> idle (or error)

Interface:
```typescript
type AutoSaveStatus = 'idle' | 'saving' | 'saved' | 'error'

function useAutoSave(
  value: string,
  onSave: (val: string) => Promise<void>,
  delay?: number // default 2000
): AutoSaveStatus
```

Pattern from research:
```typescript
function useAutoSave(value: string, onSave: (val: string) => Promise<void>, delay = 2000) {
  const [status, setStatus] = useState<AutoSaveStatus>('idle')
  const timeoutRef = useRef<NodeJS.Timeout>()
  const requestIdRef = useRef(0)

  useEffect(() => {
    if (!value) return

    setStatus('idle')
    clearTimeout(timeoutRef.current)

    timeoutRef.current = setTimeout(async () => {
      const currentRequestId = ++requestIdRef.current
      setStatus('saving')

      try {
        await onSave(value)
        if (currentRequestId === requestIdRef.current) {
          setStatus('saved')
          setTimeout(() => setStatus('idle'), 2000)
        }
      } catch {
        if (currentRequestId === requestIdRef.current) {
          setStatus('error')
        }
      }
    }, delay)

    return () => clearTimeout(timeoutRef.current)
  }, [value, onSave, delay])

  return status
}
```

Note: Wrap onSave in useCallback at call site to prevent infinite loops.
  </action>
  <verify>
1. `npm run build` passes
2. Hook exports correctly: `grep -r "useAutoSave" frontend/lib/hooks/`
3. Has race condition prevention: `grep -r "requestIdRef" frontend/lib/hooks/`
  </verify>
  <done>
useAutoSave hook exists, debounces with configurable delay, prevents race conditions, returns status indicator, and cleans up on unmount.
  </done>
</task>

</tasks>

<verification>
1. All three hooks compile: `cd frontend && npm run build`
2. Hooks directory exists: `ls frontend/lib/hooks/`
3. Each hook is exported and importable
4. No TypeScript errors in build output
</verification>

<success_criteria>
- Three hooks created in frontend/lib/hooks/
- All hooks are type-safe with proper TypeScript interfaces
- useDraftPreservation handles SSR and sessionStorage quota
- useVoiceInput handles browser compatibility and cleanup
- useAutoSave prevents race conditions and memory leaks
- Build passes with no TypeScript errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-capture--and--feedback/02-01-SUMMARY.md`
</output>
