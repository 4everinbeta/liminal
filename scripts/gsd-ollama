#!/usr/bin/env bash
set -euo pipefail

usage() {
  cat <<'EOF'
Usage:
  scripts/gsd-ollama discuss-phase <N> --model <ollama-model>
  scripts/gsd-ollama plan-phase <N> --model <ollama-model>
  scripts/gsd-ollama execute-phase <N> --model <ollama-model>
  scripts/gsd-ollama verify-phase <N> --model <ollama-model>
  scripts/gsd-ollama execute-phase <N> --model <ollama-model> --debug
  scripts/gsd-ollama execute-phase <N> --model <ollama-model> --mode json
  scripts/gsd-ollama <action> <N> --model <ollama-model> --timeout 120m

Examples:
  scripts/gsd-ollama discuss-phase 2 --model qwen3-coder:latest
  scripts/gsd-ollama plan-phase 2 --model qwen3-coder:latest
  scripts/gsd-ollama execute-phase 2 --model qwen3-coder:latest
  scripts/gsd-ollama verify-phase 2 --model glm-4.7-flash:latest

Notes:
  - Reads planning docs from .planning/
  - Writes artifacts into .planning/phases/<NN>-<slug>/
  - execute-phase generates and applies a unified diff (auto-edits files)
  - Timeout default is 60m (override with --timeout or GSD_OLLAMA_TIMEOUT)
EOF
}

die() {
  echo "error: $*" >&2
  exit 1
}

pick_plan_file() {
  local dir="$1"
  local nn="$2"

  if [[ -f "${dir}/${nn}-PLAN.md" ]]; then
    echo "${dir}/${nn}-PLAN.md"
    return 0
  fi

  # Support multi-plan outputs like 02-01-PLAN.md ... 02-04-PLAN.md
  local candidates=()
  while IFS= read -r f; do
    candidates+=("$f")
  done < <(ls -1 "${dir}/${nn}-"??-PLAN.md 2>/dev/null | sort || true)

  if [[ ${#candidates[@]} -eq 0 ]]; then
    return 1
  fi

  # Pick the highest numbered plan (last after sort).
  echo "${candidates[-1]}"
}

list_patch_paths() {
  # Extract b/<path> targets from a unified diff.
  awk '
    /^diff --git a\// {
      for (i=1;i<=NF;i++) {
        if ($i ~ /^b\//) {
          p=$i
          sub(/^b\//,"",p)
          print p
        }
      }
    }
    /^\+\+\+ b\// {
      p=$2
      sub(/^b\//,"",p)
      print p
    }
  ' | awk '!seen[$0]++'
}

validate_patch_paths() {
  # Ensure the diff only touches allowed paths.
  # - Existing files must be tracked by git.
  # - New files allowed only under certain roots (to avoid hallucinated top-level dirs).
  local allow_roots_regex='^(frontend/|backend/|docs/|scripts/)'

  local bad=0
  while IFS= read -r p; do
    [[ -z "${p:-}" ]] && continue
    if git ls-files --error-unmatch "$p" >/dev/null 2>&1; then
      continue
    fi
    if [[ "$p" =~ $allow_roots_regex ]]; then
      continue
    fi
    echo "Disallowed/untracked path in patch: $p" >&2
    bad=1
  done

  return $bad
}

validate_path_allowed() {
  local p="$1"
  local allow_roots_regex='^(frontend/|backend/|docs/|scripts/)'
  [[ "$p" =~ $allow_roots_regex ]]
}

require_cmd() {
  command -v "$1" >/dev/null 2>&1 || die "missing command: $1"
}

require_repo_clean_or_confirm() {
  if ! command -v git >/dev/null 2>&1; then
    die "missing command: git (required for execute-phase)"
  fi
  if [[ ! -d .git ]]; then
    die "execute-phase requires running inside a git repo"
  fi

  local status
  status="$(git status --porcelain)"
  if [[ -n "${status:-}" ]]; then
    echo "Working tree is not clean:" >&2
    echo "$status" >&2
    echo "" >&2
    read -r -p "Continue anyway and apply a patch on top of these changes? [y/N] " yn
    case "${yn:-}" in
      y|Y) ;;
      *) die "aborted" ;;
    esac
  fi
}

slugify() {
  # shellcheck disable=SC2001
  echo "$1" \
    | tr '[:upper:]' '[:lower:]' \
    | sed -E 's/&/ and /g; s/[^a-z0-9]+/-/g; s/^-+//; s/-+$//'
}

read_file_or_die() {
  local path="$1"
  [[ -f "$path" ]] || die "missing file: $path"
  cat "$path"
}

ollama_run() {
  local model="$1"
  shift
  local prompt="$1"
  # Ollama frequently emits spinner/control codes on stderr; suppress to keep logs readable.
  # Also apply a generous timeout so a hung model call doesn't block the workflow indefinitely.
  local args=(run "$model" --nowordwrap --think=false --hidethinking)
  if [[ "${DEBUG:-0}" -eq 1 ]]; then
    local err_file
    err_file="$(mktemp -t gsd-ollama-err.XXXXXX)"
    OLLAMA_NO_SPINNER=1 timeout "$TIMEOUT" ollama "${args[@]}" <<<"$prompt" 2>"$err_file"
    local rc=$?
    if [[ $rc -ne 0 ]]; then
      echo "Ollama stderr saved at: $err_file" >&2
      if [[ $rc -eq 124 ]]; then
        echo "Ollama timed out (${TIMEOUT})." >&2
      else
        echo "Ollama exit code: $rc" >&2
      fi
      return $rc
    fi
    rm -f "$err_file"
    return 0
  fi
  OLLAMA_NO_SPINNER=1 timeout "$TIMEOUT" ollama "${args[@]}" <<<"$prompt" 2>/dev/null
}

extract_unified_diff() {
  # Best-effort extraction of a unified diff from model output.
  # - If fenced code block exists, prefer its contents
  # - Trim everything before the first patch header ("diff --git" or "--- a/")
  local raw="$1"

  # Prefer first fenced block if present.
  # Note: "in" is a keyword in awk ("for (x in y)"), so use a different variable name.
  if printf "%s\n" "$raw" | awk 'BEGIN{inside=0} /^```/{if(inside==0){inside=1;next}else{exit}} inside==1{print}' | grep -q '^diff --git '; then
    printf "%s\n" "$raw" | awk 'BEGIN{inside=0} /^```/{if(inside==0){inside=1;next}else{exit}} inside==1{print}'
    return 0
  fi

  # If a fenced block exists but doesn't include diff --git, still try it.
  local fenced
  fenced="$(printf "%s\n" "$raw" | awk 'BEGIN{inside=0} /^```/{if(inside==0){inside=1;next}else{exit}} inside==1{print}')"
  if [[ -n "${fenced:-}" ]]; then
    raw="$fenced"
  fi

  # Otherwise, strip everything before first patch header.
  # Avoid regex literals with slashes to keep awk portable.
  printf "%s\n" "$raw" | awk 'BEGIN{found=0} /^diff --git /{found=1} substr($0,1,6)=="--- a/"{found=1} found{print}'
}

extract_repo_files_from_plan() {
  # Best-effort extraction of file paths mentioned in a plan markdown.
  # Returns newline-delimited unique paths (existing files only).
  local plan_path="$1"
  local max_files="${2:-8}"

  awk '
    {
      # Pull out backticked paths first: `frontend/...`
      while (match($0, /`(frontend|backend|infra|scripts|docs)\/[^`]+`/, m)) {
        p=m[0]
        gsub(/^`|`$/, "", p)
        print p
        $0 = substr($0, RSTART + RLENGTH)
      }
      # Then raw-looking paths
      while (match($0, /(frontend|backend|infra|scripts|docs)\/[A-Za-z0-9._\/-]+/, m2)) {
        print m2[0]
        $0 = substr($0, RSTART + RLENGTH)
      }
    }
  ' "$plan_path" \
    | awk '!seen[$0]++' \
    | while IFS= read -r p; do
        [[ -f "$p" ]] && echo "$p"
      done \
    | head -n "$max_files"
}

slurp_file_snippet() {
  local path="$1"
  local max_lines="${2:-220}"
  echo "=== FILE: ${path} ==="
  sed -n "1,${max_lines}p" "$path"
  echo ""
}

phase_title_from_roadmap() {
  local phase="$1"
  # Match: "### Phase 2: Capture & Feedback"
  # Print: "Capture & Feedback"
  awk -v phase="$phase" '
    $0 ~ "^### Phase " phase ":" {
      sub("^### Phase " phase ": *", "", $0);
      print $0;
      exit 0;
    }
  ' .planning/ROADMAP.md
}

phase_section_from_roadmap() {
  local phase="$1"
  awk -v phase="$phase" '
    $0 ~ "^### Phase " phase ":" {in_section=1}
    in_section==1 {print}
    in_section==1 && $0 ~ "^### Phase " && $0 !~ "^### Phase " phase ":" {exit 0}
  ' .planning/ROADMAP.md \
    | awk '
      NR==1 {print; next}
      # stop when next phase header would have triggered but awk above can print one extra line; keep simple:
      {print}
    '
}

ensure_phase_dir() {
  local phase="$1"
  local require_a="${2:-}"
  local require_b="${3:-}"

  local title
  title="$(phase_title_from_roadmap "$phase" || true)"
  [[ -n "${title:-}" ]] || die "phase $phase not found in .planning/ROADMAP.md"

  local nn
  nn="$(printf "%02d" "$phase")"
  local slug
  slug="$(slugify "$title")"

  local canonical=".planning/phases/${nn}-${slug}"

  # Gather candidates (canonical first, then any other 02-* dirs).
  local candidates=()
  if [[ -d "$canonical" ]]; then
    candidates+=("$canonical")
  fi
  while IFS= read -r d; do
    [[ "$d" == "$canonical" ]] && continue
    candidates+=("$d")
  done < <(find .planning/phases -maxdepth 1 -type d -name "${nn}-*" -print 2>/dev/null | sort)

  # If required files are specified, pick the first candidate that contains them.
  if [[ -n "${require_a:-}" ]]; then
    for d in "${candidates[@]}"; do
      if [[ -f "${d}/${require_a}" ]] && { [[ -z "${require_b:-}" ]] || [[ -f "${d}/${require_b}" ]]; }; then
        echo "$d"
        return 0
      fi
    done
  fi

  # If we have exactly one candidate, use it.
  if [[ ${#candidates[@]} -eq 1 ]]; then
    echo "${candidates[0]}"
    return 0
  fi

  # If no candidates exist yet, create canonical.
  if [[ ${#candidates[@]} -eq 0 ]]; then
    mkdir -p "$canonical"
    echo "$canonical"
    return 0
  fi

  # Prefer canonical if it exists (even if empty) for discuss-phase.
  if [[ -z "${require_a:-}" ]] && [[ -d "$canonical" ]]; then
    echo "$canonical"
    return 0
  fi

  echo "error: cannot select a phase directory for phase ${phase}." >&2
  echo "Candidates:" >&2
  for d in "${candidates[@]}"; do
    echo "  - $d" >&2
  done
  if [[ -n "${require_a:-}" ]]; then
    echo "Required file(s): ${require_a}${require_b:+, ${require_b}}" >&2
  fi
  die "rename/delete the wrong directory, or re-run discuss/plan to generate missing artifacts"
}

parse_args() {
  local action="$1"
  shift

  [[ $# -ge 1 ]] || die "missing phase number"
  PHASE="$1"
  shift

  MODEL=""
  DEBUG=0
  MODE="diff"
  TIMEOUT="${GSD_OLLAMA_TIMEOUT:-60m}"
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --model|-m)
        shift
        [[ $# -gt 0 ]] || die "missing value for --model"
        MODEL="$1"
        shift
        ;;
      --debug)
        DEBUG=1
        shift
        ;;
      --mode)
        shift
        [[ $# -gt 0 ]] || die "missing value for --mode (diff|json)"
        MODE="$1"
        shift
        ;;
      --timeout)
        shift
        [[ $# -gt 0 ]] || die "missing value for --timeout (e.g. 60m, 2h)"
        TIMEOUT="$1"
        shift
        ;;
      -h|--help)
        usage
        exit 0
        ;;
      *)
        die "unknown argument: $1"
        ;;
    esac
  done

  [[ "$PHASE" =~ ^[0-9]+$ ]] || die "phase must be an integer (got: $PHASE)"
  [[ -n "$MODEL" ]] || die "missing --model"
  [[ "$MODE" == "diff" || "$MODE" == "json" ]] || die "invalid --mode (expected diff|json): $MODE"
  [[ -n "$TIMEOUT" ]] || die "missing timeout value"
}

discuss_phase() {
  local phase="$1"
  local model="$2"

  local dir
  dir="$(ensure_phase_dir "$phase")"

  local state roadmap requirements
  state="$(read_file_or_die .planning/STATE.md)"
  roadmap="$(read_file_or_die .planning/ROADMAP.md)"
  requirements="$(read_file_or_die .planning/REQUIREMENTS.md)"

  local phase_section
  phase_section="$(phase_section_from_roadmap "$phase")"
  [[ -n "${phase_section:-}" ]] || die "could not extract phase $phase section from .planning/ROADMAP.md"

  local meta_prompt
  meta_prompt=$(
    cat <<EOF
You are helping create a Phase ${phase} implementation context file.

Return ONLY lines in this exact machine-readable format (no markdown):
AREA|<short area title>
Q|<question 1>
Q|<question 2>
Q|<question 3>
Q|<question 4>
END
(repeat AREA/Q/Q/Q/Q/END for exactly 4 areas)

Constraints:
- Areas must be specific to the phase goal and success criteria.
- Questions must force concrete choices (not vague vision).
- Do not propose new scope outside the phase boundary; if something feels out-of-scope, ask a question that lets us defer it.

Inputs:

=== PHASE SECTION (from ROADMAP.md) ===
${phase_section}

=== CURRENT STATE (STATE.md) ===
${state}

=== REQUIREMENTS (REQUIREMENTS.md) ===
${requirements}

EOF
  )

  echo "Generating discussion areas/questions with Ollama model: $model" >&2
  local outline
  outline="$(ollama_run "$model" "$meta_prompt")"

  local qa_file
  qa_file="$(mktemp)"
  printf "%s\n" "# Phase ${phase} Q&A" >"$qa_file"
  printf "%s\n\n" "_Generated by scripts/gsd-ollama; answer in terminal prompts._" >>"$qa_file"

  local current_area=""
  local question=""
  while IFS= read -r line; do
    case "$line" in
      AREA\|*)
        current_area="${line#AREA|}"
        echo "" >>"$qa_file"
        echo "## ${current_area}" >>"$qa_file"
        ;;
      Q\|*)
        question="${line#Q|}"
        echo "" >&2
        echo "[$current_area] $question" >&2
        read -r -p "> " answer
        echo "- Q: ${question}" >>"$qa_file"
        echo "  A: ${answer}" >>"$qa_file"
        ;;
      END)
        ;;
      *)
        # Ignore stray lines so the flow continues even if the model is imperfect.
        ;;
    esac
  done <<<"$outline"

  local context_prompt
  context_prompt=$(
    cat <<EOF
Write a Phase ${phase} context file as markdown.

Goal: capture implementation decisions that downstream work needs, based on the user's answers.

Must include:
- Phase summary (1 paragraph) aligned to the roadmap phase goal and success criteria.
- Decisions (bullet lists) grouped by the 4 areas.
- Open questions / unknowns (if any remain).
- Deferred ideas (explicitly out-of-scope for this phase).
- Acceptance notes: restate the success criteria and how we’ll know we met them.

Do NOT include code. Do NOT suggest new scope.

Inputs:

=== PHASE SECTION (from ROADMAP.md) ===
${phase_section}

=== USER Q&A ===
$(cat "$qa_file")

EOF
  )

  echo "" >&2
  echo "Generating CONTEXT.md with Ollama model: $model" >&2
  local context
  context="$(ollama_run "$model" "$context_prompt")"

  local out_path="${dir}/$(printf "%02d" "$phase")-CONTEXT.md"
  printf "%s\n" "$context" >"$out_path"
  echo "Wrote: $out_path" >&2
}

plan_phase() {
  local phase="$1"
  local model="$2"

  local dir
  local nn
  nn="$(printf "%02d" "$phase")"
  dir="$(ensure_phase_dir "$phase" "${nn}-CONTEXT.md")"

  local context_path="${dir}/${nn}-CONTEXT.md"
  [[ -f "$context_path" ]] || die "missing context file: $context_path (run: scripts/gsd-ollama discuss-phase $phase --model ...)"

  local phase_section
  phase_section="$(phase_section_from_roadmap "$phase")"

  local plan_prompt
  plan_prompt=$(
    cat <<EOF
Create a concrete implementation plan for Phase ${phase} as markdown.

Hard requirements:
- Include a deliverables checklist with acceptance criteria per item.
- Include a file-by-file touch list (frontend/backend/scripts/etc). Use best guesses but be specific.
- Include verification steps (tests or manual checks) that map to the roadmap success criteria.
- Keep scope strictly within Phase ${phase}.

Inputs:

=== PHASE SECTION (from ROADMAP.md) ===
${phase_section}

=== CONTEXT (${nn}-CONTEXT.md) ===
$(cat "$context_path")

=== REPO TOP-LEVEL ===
$(ls -1)

EOF
  )

  echo "Generating plan with Ollama model: $model" >&2
  local plan
  plan="$(ollama_run "$model" "$plan_prompt")"

  local out_path="${dir}/${nn}-PLAN.md"
  printf "%s\n" "$plan" >"$out_path"
  echo "Wrote: $out_path" >&2
}

execute_phase() {
  local phase="$1"
  local model="$2"

  require_repo_clean_or_confirm

  local dir
  local nn
  nn="$(printf "%02d" "$phase")"
  # We require context, but plan might be either 02-PLAN.md or 02-0X-PLAN.md.
  dir="$(ensure_phase_dir "$phase" "${nn}-CONTEXT.md")"

  local context_path="${dir}/${nn}-CONTEXT.md"
  local plan_path
  plan_path="$(pick_plan_file "$dir" "$nn" || true)"

  [[ -f "$context_path" ]] || die "missing context file: $context_path (run: scripts/gsd-ollama discuss-phase $phase --model ...)"
  [[ -n "${plan_path:-}" ]] || die "missing plan file in ${dir} (expected ${nn}-PLAN.md or ${nn}-0X-PLAN.md; run: scripts/gsd-ollama plan-phase $phase --model ...)"
  [[ -f "$plan_path" ]] || die "missing plan file: $plan_path"

  local phase_section
  phase_section="$(phase_section_from_roadmap "$phase")"

  local repo_files_context=""
  local mentioned
  mentioned="$(extract_repo_files_from_plan "$plan_path" 8 || true)"
  local allowed_files=""
  if [[ -n "${mentioned:-}" ]]; then
    while IFS= read -r f; do
      repo_files_context+=$(slurp_file_snippet "$f" 220)
      allowed_files+="${f}"$'\n'
    done <<<"$mentioned"
  fi

  local prompt
  prompt=$(
    cat <<EOF
You are an expert coding agent working inside a git repository.

Task: implement the NEXT smallest chunk of Phase ${phase}.

Return ONLY a unified diff that can be applied with 'git apply'. No markdown. No explanations. No code fences.

Rules:
- Keep the patch small and reviewable (ideally 1–4 files).
- Do not modify planning docs under .planning/ (except if absolutely necessary for tracking; prefer no).
- If you need to add new files, include them in the diff.
- If you need follow-up work, encode it as TODOs in the plan output? NO. Only code changes in the diff.
- Ensure code compiles/lints by best effort, but do not run commands.
- Do NOT invent file contents. Use the provided file snapshots when editing existing files.
- Do NOT create or edit files outside: frontend/, backend/, docs/, scripts/.

Inputs:

=== PHASE SECTION (from ROADMAP.md) ===
${phase_section}

=== CONTEXT (${nn}-CONTEXT.md) ===
$(cat "$context_path")

=== PLAN (${nn}-PLAN.md) ===
$(cat "$plan_path")

=== REPO SNAPSHOT ===
Top-level:
$(ls -1)

Recent commits:
$(git --no-pager log -n 8 --oneline 2>/dev/null || true)

=== ALLOWED FILES (prefer editing these) ===
${allowed_files}

=== FILE SNAPSHOTS (authoritative) ===
${repo_files_context}

EOF
  )

  local attempt=1
  local max_attempts=3
  local last_patch_file=""

  if [[ "${MODE:-diff}" == "json" ]]; then
    attempt=$((max_attempts + 1))
  fi

  while [[ $attempt -le $max_attempts ]]; do
    echo "Generating patch with Ollama model: $model (attempt $attempt/$max_attempts)" >&2
    local raw
    raw="$(ollama_run "$model" "$prompt")"

    if [[ "${DEBUG:-0}" -eq 1 ]]; then
      local raw_file
      raw_file="/tmp/gsd-ollama-exec-${nn}-attempt-${attempt}.raw.txt"
      printf "%s\n" "$raw" >"$raw_file"
      echo "Saved raw model output: $raw_file" >&2
    fi

    local patch
    patch="$(extract_unified_diff "$raw")"

    if [[ -z "${patch//$'\n'/}" ]]; then
      echo "" >&2
      echo "Model did not return a usable patch body." >&2
      if [[ "${DEBUG:-0}" -eq 1 ]]; then
        echo "Raw output (first 40 lines):" >&2
        printf "%s\n" "$raw" | sed -n '1,40p' >&2 || true
      fi
      if [[ $attempt -lt $max_attempts ]]; then
        prompt="${prompt}"$'\n'"IMPORTANT: Your previous output was not a patch. Return ONLY a unified diff (git apply compatible). Start with either 'diff --git' or '--- a/'. No prose. No code fences. No JSON."
        attempt=$((attempt + 1))
        continue
      fi
      die "model did not return a patch"
    fi

    local patch_file
    patch_file="$(mktemp)"
    last_patch_file="$patch_file"
    printf "%s\n" "$patch" >"$patch_file"

    # Reject patches that touch hallucinated/untracked paths (e.g., app/page.tsx).
    if ! list_patch_paths <"$patch_file" | validate_patch_paths; then
      echo "" >&2
      echo "Patch touches disallowed/untracked paths. Saved at: $patch_file" >&2
      echo "First few lines:" >&2
      sed -n '1,40p' "$patch_file" >&2 || true
      if [[ $attempt -lt $max_attempts ]]; then
        prompt="${prompt}"$'\n'"IMPORTANT: The previous diff touched invalid paths. Only edit existing tracked files, or create new files ONLY under frontend/, backend/, docs/, scripts/. Return ONLY a unified diff."
        attempt=$((attempt + 1))
        continue
      fi
      exit 1
    fi

    # Validate before applying to avoid partial application.
    if ! git apply --check "$patch_file" >/dev/null 2>&1; then
      echo "" >&2
      echo "Patch failed validation (git apply --check). Saved at: $patch_file" >&2
      echo "First few lines:" >&2
      sed -n '1,40p' "$patch_file" >&2 || true
      if [[ $attempt -lt $max_attempts ]]; then
        prompt="${prompt}"$'\n'"IMPORTANT: The previous diff did not apply cleanly. Generate a smaller patch that applies to the current repo state. Return ONLY a unified diff. Avoid large refactors."
        attempt=$((attempt + 1))
        continue
      fi
      exit 1
    fi

    echo "Applying patch..." >&2
    if ! git apply "$patch_file"; then
      echo "" >&2
      echo "Patch failed to apply (unexpected after --check). Saved at: $patch_file" >&2
      exit 1
    fi

    rm -f "$patch_file"
    echo "Patch applied. Current status:" >&2
    git status --short >&2
    return 0
  done

  # Fallback: request structured file edits and write them directly.
  echo "" >&2
  echo "Falling back to JSON file-edit mode (model isn't producing applyable diffs)..." >&2

  local json_prompt
  json_prompt=$(
    cat <<EOF
Return ONLY JSON (no markdown, no prose) with this schema:
{
  "files": [
    {"path": "frontend/...", "content": "<full file contents>"},
    ...
  ]
}

Rules:
- Only include paths under frontend/, backend/, docs/, scripts/.
- Provide complete file contents for each entry.
- Keep it small: 1–3 files max.
- Do not invent new app structure; prefer editing the ALLOWED FILES list.

Task: implement the NEXT smallest chunk of Phase ${phase} using the context and plan below.

=== PHASE SECTION ===
${phase_section}

=== CONTEXT ===
$(cat "$context_path")

=== PLAN ===
$(cat "$plan_path")

=== ALLOWED FILES (prefer editing these) ===
${allowed_files}

=== FILE SNAPSHOTS (authoritative) ===
${repo_files_context}
EOF
  )

  local json_raw
  json_raw="$(ollama_run "$model" "$json_prompt")" || die "model call failed during JSON fallback"

  if [[ "${DEBUG:-0}" -eq 1 ]]; then
    local json_file
    json_file="/tmp/gsd-ollama-exec-${nn}-files.json"
    printf "%s\n" "$json_raw" >"$json_file"
    echo "Saved JSON edit payload: $json_file" >&2
  fi

  require_cmd python3
  python3 - <<'PY' "$json_raw"
import json, os, sys

raw = sys.argv[1]
try:
    data = json.loads(raw)
except Exception as e:
    print("error: JSON parse failed:", e, file=sys.stderr)
    sys.exit(2)

files = data.get("files")
if not isinstance(files, list) or not files:
    print("error: JSON must include non-empty 'files' list", file=sys.stderr)
    sys.exit(2)

def allowed(path: str) -> bool:
    return path.startswith(("frontend/","backend/","docs/","scripts/")) and ".." not in path and not path.startswith("/")

for item in files:
    if not isinstance(item, dict):
        print("error: each files[] entry must be an object", file=sys.stderr)
        sys.exit(2)
    path = item.get("path")
    content = item.get("content")
    if not isinstance(path, str) or not isinstance(content, str):
        print("error: each entry must have string 'path' and 'content'", file=sys.stderr)
        sys.exit(2)
    if not allowed(path):
        print(f"error: disallowed path: {path}", file=sys.stderr)
        sys.exit(2)
    os.makedirs(os.path.dirname(path), exist_ok=True)
    with open(path, "w", encoding="utf-8") as f:
        f.write(content)
PY

  echo "Wrote files from JSON payload. Current status:" >&2
  git status --short >&2
  return 0
}

verify_phase() {
  local phase="$1"
  local model="$2"

  local dir
  local nn
  nn="$(printf "%02d" "$phase")"
  # Plan might be either 02-PLAN.md or 02-0X-PLAN.md.
  dir="$(ensure_phase_dir "$phase")"

  local plan_path
  plan_path="$(pick_plan_file "$dir" "$nn" || true)"
  [[ -n "${plan_path:-}" ]] || die "missing plan file in ${dir} (expected ${nn}-PLAN.md or ${nn}-0X-PLAN.md; run: scripts/gsd-ollama plan-phase $phase --model ...)"
  [[ -f "$plan_path" ]] || die "missing plan file: $plan_path"

  local phase_section
  phase_section="$(phase_section_from_roadmap "$phase")"

  local verify_prompt
  verify_prompt=$(
    cat <<EOF
You are a verifier. Produce a Phase ${phase} verification checklist as markdown.

Include:
- A checklist mapped to each roadmap success criterion for Phase ${phase}.
- A checklist mapped to the plan deliverables.
- What evidence to capture (screenshots, logs, test output) for each.
- A short "If failing, likely causes" section.

Do not claim work is complete. This is a verification plan, not a verdict.

Inputs:

=== PHASE SECTION (from ROADMAP.md) ===
${phase_section}

=== PLAN ($(basename "$plan_path")) ===
$(cat "$plan_path")

EOF
  )

  echo "Generating verification checklist with Ollama model: $model" >&2
  local verify
  verify="$(ollama_run "$model" "$verify_prompt")"

  local out_path="${dir}/${nn}-VERIFY.md"
  printf "%s\n" "$verify" >"$out_path"
  echo "Wrote: $out_path" >&2
}

main() {
  require_cmd ollama
  require_cmd awk
  require_cmd sed
  require_cmd tr
  require_cmd mktemp
  require_cmd timeout

  [[ $# -ge 1 ]] || { usage; exit 1; }
  local action="$1"
  shift

  case "$action" in
    discuss-phase|plan-phase|execute-phase|verify-phase)
      parse_args "$action" "$@"
      ;;
    -h|--help|help)
      usage
      exit 0
      ;;
    *)
      die "unknown action: $action"
      ;;
  esac

  case "$action" in
    discuss-phase) discuss_phase "$PHASE" "$MODEL" ;;
    plan-phase) plan_phase "$PHASE" "$MODEL" ;;
    execute-phase) execute_phase "$PHASE" "$MODEL" ;;
    verify-phase) verify_phase "$PHASE" "$MODEL" ;;
  esac
}

PHASE=""
MODEL=""
DEBUG=0
MODE="diff"
TIMEOUT="${GSD_OLLAMA_TIMEOUT:-60m}"
main "$@"
